
#--------------------------------------------------------------------------------------
# chronology on all phases
#--------------------------------------------------------------------------------------
# To do:
# Prioritise phases that haven't been done yet
# Change loop structure so it can process norm and ellipsoid models together
# Structure prior(s) in a Bayesian chain, using parameters derived empirically from the entire database
# Ensure resolution and range of prior is compatible with different resolution and range of previous posteriors

#--------------------------------------------------------------------------------------
model.folder <- '../../phase model posteriors/gaussian'
library(ADMUR)
#--------------------------------------------------------------------------------------
sit <- query.database(user, password, 'biad',"SELECT * FROM `Sites`;")
pha <- query.database(user, password, 'biad',"SELECT * FROM `Phases`;")
c14 <- query.database(user, password, 'biad',"SELECT `PhaseID`,`SiteID`,`C14.Age`,`C14.SD` FROM `C14Samples`;")
pha <- merge(pha,sit,by='SiteID', all.y=FALSE)
c14 <- subset(c14, !is.na(PhaseID))

# create a prior probability surface
mu.range <- c(500,40000)
sigma.range <- c(10,1000)
prior.matrix.initial <- matrix(1,200,200); prior.matrix.initial <- prior.matrix.initial/sum(prior.matrix.initial)
row.names(prior.matrix.initial) <- seq(min(mu.range),max(mu.range),length.out=nrow(prior.matrix.initial))
colnames(prior.matrix.initial) <- seq(min(sigma.range),max(sigma.range),length.out=ncol(prior.matrix.initial))

N <- 250
for(n in 1:N){

	# pick a random phase
	# change to the prioritisation order
	i <- sample(1:nrow(pha),size=1)
	phase <- pha[i,]

	print(phase)

	# get other phases with same culture and period, within 100km
	cultures <- phase[,c('Culture1','Culture2','Culture3')]
	cultures <- cultures[!is.na(cultures)]
	near.phases <- subset(pha, Culture1%in%cultures & Period%in%phase$Period & PhaseID!=phase$PhaseID)
	if(nrow(near.phases)>0){
		near.phases$dist <- slc(x=phase$Longitude, y=phase$Latitude, ax=near.phases$Longitude, ay=near.phases$Latitude, input='deg') * 6378.1
		near.phases <- subset(near.phases,dist<100)
		}

	# if no other phases available, get phases with same period within 100km
	if(nrow(near.phases)==0){
		near.phases <- subset(pha, Period%in%phase$Period & PhaseID!=phase$PhaseID)
		if(nrow(near.phases)>0){
			near.phases$dist <- slc(x=phase$Longitude, y=phase$Latitude, ax=near.phases$Longitude, ay=near.phases$Latitude, input='deg') * 6378.1
			near.phases <- subset(near.phases,dist<100)
			}
		}

	# reduce to informative phases (that have a posterior model already)
	already <- gsub('.RData','',list.files(model.folder))
	near.phases <- near.phases[near.phases$PhaseID%in%already,]

	# generate the new prior from the posteriors of the near phases
	NP <- nrow(near.phases)
	prior.matrix <- prior.matrix.initial
	if(NP>0)for(np in 1:NP){
		load(paste(model.folder,paste(near.phases$PhaseID[np],'RData',sep='.'),sep='/'))
		if(!is.nan(sum(mod$posterior)))prior.matrix <- prior.matrix + mod$posterior
		}
	prior.matrix <- prior.matrix/sum(prior.matrix)

	# get phase c14 dates
	d <- subset(c14, PhaseID==phase$PhaseID)
	data <- data.frame(age=d$C14.Age, sd=d$C14.SD)

	# generate the phase model
	mod <- phaseModel(data, calcurve=intcal20, prior.matrix, model='norm', plot = FALSE)

	# save the model in folder 
	save(mod, file=paste(model.folder,paste(phase$PhaseID,'RData',sep='.'),sep='/'))
	# add point estimates to the database if the posterior is reasonably tight
	cond <- max(mod$posterior)/mean(mod$posterior)>10
	if(cond){
		sql.command <- paste("UPDATE `BIAD`.`Phases` SET `gaussianModelMu`=",mod$mu,", `gaussianModelSigma`=",mod$sigma," WHERE `PhaseID`='",phase$PhaseID,"';",sep='')
		query.database(user, password, 'biad',sql.command)
		}
	}
#-----------------------------------------------------------------------------------------

files <- list.files('Z:/Users/admin/Github/phase model posteriors/gaussian', full.names=TRUE)
N <- length(files)
for(n in 1:N){
	load(files[n])
	if(is.nan(sum(mod$posterior)))print(files[n])
	}








